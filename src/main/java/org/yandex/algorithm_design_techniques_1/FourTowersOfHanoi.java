package org.yandex.algorithm_design_techniques_1;

import java.util.Scanner;

/**
 * Описание: Головоломка <<Ханойские башни>> состоит из трёх стержней, пронумеруем их слева направо: 1, 2 и 3.
 * Также в головоломке используется стопка дисков с отверстием посередине. Радиус дисков уменьшается снизу вверх.
 * Изначально диски расположены на левом стержне (стержень 1), самый большой диск находится внизу. Диски в игре
 * перемещаются по одному со стержня на стержень. Диск можно надеть на стержень, только если он пустой или верхний диск
 * на нём большего размера, чем перемещаемый. Цель головоломки — перенести все диски со стержня 1 на стержень 3.
 * Требуется найти последовательность ходов, которая решает головоломку <<Ханойские башни>>.
 * <p>
 * Немного изменим правила. Теперь головоломка состоит из четырех стержней, а цель головоломки — перенести все диски со
 * стержня 1 на стержень 4. Найдите минимальное количество ходов, за которое можно решить головоломку.
 * <p>
 * Формат ввода: В первой строке находится одно число n (3 <= n <= 10) - количество дисков на первой башне.
 * <p>
 * Формат вывода: В единственной строке выведите ответ на задачу.
 */
public class FourTowersOfHanoi {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int discs = scanner.nextInt();
        scanner.close();

        if (discs >= 3 && discs <= 10) {
            int totalOperations = recursionOfTheHanoiTowers(discs);
            System.out.println(totalOperations);
        } else System.out.println("Неправильный ввод");
    }

    /**
     * Рекурсивный метод для решения задачи "Ханойские башни".
     *
     * @param discs количество дисков
     * @return минимальное количество шагов
     */
    public static int recursionOfTheHanoiTowers(int discs) {
        // Базовый случай: если дисков нет, возвращаем 0 (нет шагов).
        if (discs == 0) {
            return 0;
        }
        // Базовый случай: если есть только один диск, возвращаем 1 (один шаг).
        if (discs == 1) {
            return 1;
        }

        // Вычисляем значение переменной k с использованием формулы (диофантово уравнение)
        int k = (int) (Math.sqrt(1 + 8 * discs) - 1) / 2;

        // Рекурсивно вызываем метод для дисков, уменьшенных на k (количество дисков, которые уже перемещены).
        // Умножаем результат на 2, так как каждый рекурсивный вызов включает два шага (вперед и назад).
        // Добавляем значение 2^k - 1, что учитывает минимальное количество шагов для перемещения дисков между стержнями.
        return recursionOfTheHanoiTowers(discs - k) * 2 + (int) Math.pow(2, k) - 1;
    }
}
